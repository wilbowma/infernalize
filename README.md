infernalize
===
A dependently typed language in which type inference is internalized into the
object language.
Dependent types usually internalize type checking, via the type `Type`, and
sometimes internalize type equality, via the identity type, but I've never seen
one internalize type inference.

This language does, and appears to have applications in defining types for macros.
It is heavily inspired by "Inferring Type Rules for Syntactic Sugar" by Justin Pombrio.
http://cs.brown.edu/research/plt/dl/pldi2018/inferring-type-rules.pdf

## infernal type theory
The key rules are:

```
Γ ⊢ e : A
-------------------
Γ ⊢ infer e : Type

Γ ⊢ e : A
----------------
Γ ⊢ infer e ≡ A
```

The term `infer e` is a term-level witness to the fact that the type system
computes some types during checking.
The idea is for `infer e` to be generated by a macro in order to insert locally
computable type annotations, without requiring a sophisticated type system such
as one unification.
Unification and bi-directional typing are more powerful techniques, but complex
to model in a type system, and require non-local changes to the model.
By contrast, we can use `infer e` to give types to macro-like functions, and
then simple pattern-based macros to insert the necessary `infer`s.

## Using `infer` to calculate a typing rule
We can use `infer` to soundly calculate typing rules for macros.
For example, we give a functional implementation of `let` the following type.
```
let- : Π(A:Type, e:A, B:Πx:A.Type, f:Πx:A.B x). (B e)
```
This type is essentially equivalent to the typing rule:
```
Γ ⊢ A : Type
Γ ⊢ e : A
Γ ⊢ B : Πx:A.Type
Γ ⊢ f : Πx:A.(B x)
------------------------
Γ ⊢ let- A e B f : (B e)
```

Observe that simple meta-theoretic properties tell us that, since `Γ ⊢ e : A`,
`Γ ⊢ A : Type`.
Therefore, the input `A` is not necessary in the term language; it can always be
inferred.
(This may require knowing that `A` is not used in a computationally relevant way
in the implementation of `let-`.)
Similarly with `B`.
This is the property that `infer` captures as a term.
So we can simplify the typing rule to the following.

```
Γ ⊢ e : A
Γ ⊢ f : Πx:A.(B x)
------------------------
Γ ⊢ let- e f : (B e)
```

Knowledge of the binding structure of `f` and `B` tells us we could simplify
this further, by replacing the applications of `B` by substitution.

```
Γ ⊢ e : A
Γ ⊢ f : Πx:A.B
------------------------
Γ ⊢ let- e f : B[e/x]
```

If we had the ability to introduce new syntax and binding forms, we
could derive pretty close to the expected typing rule for `let`.
This requires understanding telescopes, i.e., understanding that
`Γ ⊢ f : Π x:A.B = Γ, x:A ⊢ (f x) : Π x:A.B` .


```
Γ ⊢ e : A
Γ,x:A ⊢ (f x) : B
------------------------
Γ ⊢ let- x = e in (f x) : B[e/x]
```

If we had simple macros, we could implement this `let` macro as follows
and derive the expected typing rule through partial evaluation.
```
(let x = e in e') => let- (infer e) e (λx:(infer e). (infer e') (λx:(infer e). e')
```

Now we instantiate the above typing rule for `let-` as follows.
```
Γ ⊢ e : A
Γ,x:A ⊢ ((λx:(infer e). e') x) : B
------------------------
Γ ⊢ let x = e in ((λx:(infer e). e') x) : B[e/x]
```

And partially evaluate terms, in particular `((λx:(infer e). e') x) -> e'`, to
calculate the standard typing rule for `let`.
Note that all sub-expressions are well-typed in `infernalize`, so the evaluation
is safe.

```
Γ ⊢ e : A
Γ,x:A ⊢ e': B
------------------------
Γ ⊢ let x = e in e' : B[e/x]
```

## Goal
Ultimately, I want to be able to give types to macros.
I think being able to calculate a typing rule in a type theory is a good first
step.
To do that, I want the calculation to be reflected directly in the term, so
we can calculate in the object language (the terms of `infernalize`), and then,
as a final step, translate to a typing rule.
Unfortunately, too much of this calculation still happens over the typing rule;
the term or type is not a good enough representation of the typing rule.

In the above example, we generated a typing rule for `let-` first, and then
started modifying it.
Instead, I would prefer to start from, e.g., the type of `let-` and the macro
definition for `let`, then perform some calculations, after which we end up with
exactly the typing rule for `let`.

1.
  ```
  let- : Π(A:Type, e:A, B:Πx:A.Type, f:Πx:A.B x). (B e)
  (let x = e in e') => let- (infer e) e (λx:(infer e). (infer e') (λx:(infer e). e')
  ```
2. ???
3.
  ```
  Γ ⊢ e : A
  Γ,x:A ⊢ e': B
  ------------------------
  Γ ⊢ let x = e in e' : B[e/x]
  ```

I think step 2. requires some control over partial evaluation, but I'm not quite
sure what that looks like yet.
